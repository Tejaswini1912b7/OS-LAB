AIM  :  To write a C program for implementation of Round Robin Algorithm

ALGORITHM:
START
	Input the Arrival and Burst Times of all the required Processes.
	Organize all processes according to their arrival time in the ready queue.
	The queue structure of the ready queue is based on the FIFO structure to execute all CPU processes.
	Now, Push the first process from the ready queue to execute its task for a fixed time, allocated by each process that arrives in the queue.
	If the burst time of the process is left, push the process end of the ready queue.
	CPU saves the previous state of the process, which helps to resume from the point where it is interrupted. 
	The scheduler selects another process from the ready queue to execute its tasks. 
	When a process finishes its task when it's burst time is finished.
	Similarly, Repeat all the steps to execute the process until the work has finished.
STOP

CODE:
// Round Robin Scheduling
#include<stdio.h>
int main()
{
    int wait_time = 0, turnaround_time = 0, arrival_time[100], burst_time[100], temp[100];
    int i, limit, total = 0, x, counter = 0, time_quantum;
    float average_wait_time, average_turnaround_time;
    printf("Enter Total Number of Processes : ");
    scanf("%d", &limit);
    x = limit;
    for(i = 0; i < limit; i++)
    {
        printf("Enter Details of Process[%d]", i + 1);
        printf("\nArrival Time :  ");
        scanf("%d", &arrival_time[i]);
        printf("Burst Time   :  ");
        scanf("%d", &burst_time[i]);
        temp[i] = burst_time[i];
    }
    printf("Enter Time Quantum :  ");
    scanf("%d", &time_quantum);
    printf("\nProcess ID\t\tBurst Time\t Turnaround Time\t Waiting Time");
    for(total = 0, i = 0; x != 0;)
    {
        if(temp[i] <= time_quantum && temp[i] > 0)
        {
            total = total + temp[i];
            temp[i] = 0;
            counter = 1;
        }
        else if(temp[i] > 0)
        {
            temp[i] = temp[i] - time_quantum;
            total = total + time_quantum;
        }
        if(temp[i] == 0 && counter == 1)
        {
            x--;
            printf("\nProcess[%d]\t\t%d\t\t %d\t\t\t %d", i + 1, burst_time[i], total - arrival_time[i], total - arrival_time[i] - burst_time[i]);
            wait_time = wait_time + total - arrival_time[i] - burst_time[i];
            turnaround_time = turnaround_time + total - arrival_time[i];
            counter = 0;
        }
        if(i == limit - 1)
        {
            i = 0;
        }
        else if(arrival_time[i + 1] <= total)
        {
            i++;
        }
        else
        {
            i = 0;
        }
    }
    average_wait_time = wait_time * 1.0 / limit;
    average_turnaround_time = turnaround_time * 1.0 / limit;
    printf("\n\nAverage Waiting Time :  %f", average_wait_time);
    printf("\nAvg Turnaround Time    :   %f\n", average_turnaround_time);
    return 0;
}

